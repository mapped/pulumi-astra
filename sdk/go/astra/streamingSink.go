// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package astra

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `StreamingSink` creates a streaming sink which sends data from a topic to a target system.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"encoding/json"
//
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/pulumiverse/pulumi-astra/sdk/go/astra"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := astra.NewStreamingTenant(ctx, "streamingTenant-1", &astra.StreamingTenantArgs{
// 			TenantName:    pulumi.String("terraformtest2"),
// 			Topic:         pulumi.String("terraformtest"),
// 			Region:        pulumi.String("useast-4"),
// 			CloudProvider: pulumi.String("gcp"),
// 			UserEmail:     pulumi.String("seb@datastax.com"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = astra.NewCdc(ctx, "cdc-1", &astra.CdcArgs{
// 			DatabaseId:      pulumi.String("5b70892f-e01a-4595-98e6-19ecc9985d50"),
// 			DatabaseName:    pulumi.String("sai_test"),
// 			Table:           pulumi.String("test"),
// 			Keyspace:        pulumi.String("sai_test"),
// 			TopicPartitions: pulumi.Int(3),
// 			TenantName:      streamingTenant_1.TenantName,
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			streamingTenant_1,
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		tmpJSON0, err := json.Marshal(map[string]interface{}{
// 			"userName":  "clickhouse",
// 			"password":  "password",
// 			"jdbcUrl":   "jdbc:clickhouse://fake.clickhouse.url:8123/pulsar_clickhouse_jdbc_sink",
// 			"tableName": "pulsar_clickhouse_jdbc_sink",
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		json0 := string(tmpJSON0)
// 		_, err = astra.NewStreamingSink(ctx, "streamingSink-1", &astra.StreamingSinkArgs{
// 			TenantName:           streamingTenant_1.TenantName,
// 			Topic:                cdc_1.DataTopic,
// 			Region:               pulumi.String("useast-4"),
// 			CloudProvider:        pulumi.String("gcp"),
// 			SinkName:             pulumi.String("jdbc-clickhouse"),
// 			RetainOrdering:       pulumi.Bool(true),
// 			ProcessingGuarantees: pulumi.String("ATLEAST_ONCE"),
// 			Parallelism:          pulumi.Int(3),
// 			Namespace:            pulumi.String("default"),
// 			SinkConfigs:          pulumi.String(json0),
// 			AutoAck:              pulumi.Bool(true),
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			streamingTenant_1,
// 			cdc_1,
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ```sh
//  $ pulumi import astra:index/streamingSink:StreamingSink example tenant_name/topic
// ```
type StreamingSink struct {
	pulumi.CustomResourceState

	// auto ack
	AutoAck pulumi.BoolOutput `pulumi:"autoAck"`
	// Cloud provider
	CloudProvider pulumi.StringOutput `pulumi:"cloudProvider"`
	// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
	// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
	DeletionProtection pulumi.BoolPtrOutput `pulumi:"deletionProtection"`
	// Pulsar Namespace
	Namespace pulumi.StringOutput `pulumi:"namespace"`
	// Parallelism for Pulsar sink
	Parallelism pulumi.IntOutput `pulumi:"parallelism"`
	// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
	ProcessingGuarantees pulumi.StringOutput `pulumi:"processingGuarantees"`
	// cloud region
	Region pulumi.StringOutput `pulumi:"region"`
	// Retain ordering.
	RetainOrdering pulumi.BoolOutput `pulumi:"retainOrdering"`
	// Sink Configs
	SinkConfigs pulumi.StringOutput `pulumi:"sinkConfigs"`
	// Name of the sink.
	SinkName pulumi.StringOutput `pulumi:"sinkName"`
	// Streaming tenant name.
	TenantName pulumi.StringOutput `pulumi:"tenantName"`
	// Streaming tenant topic.
	Topic pulumi.StringOutput `pulumi:"topic"`
}

// NewStreamingSink registers a new resource with the given unique name, arguments, and options.
func NewStreamingSink(ctx *pulumi.Context,
	name string, args *StreamingSinkArgs, opts ...pulumi.ResourceOption) (*StreamingSink, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AutoAck == nil {
		return nil, errors.New("invalid value for required argument 'AutoAck'")
	}
	if args.CloudProvider == nil {
		return nil, errors.New("invalid value for required argument 'CloudProvider'")
	}
	if args.Namespace == nil {
		return nil, errors.New("invalid value for required argument 'Namespace'")
	}
	if args.Parallelism == nil {
		return nil, errors.New("invalid value for required argument 'Parallelism'")
	}
	if args.ProcessingGuarantees == nil {
		return nil, errors.New("invalid value for required argument 'ProcessingGuarantees'")
	}
	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	if args.RetainOrdering == nil {
		return nil, errors.New("invalid value for required argument 'RetainOrdering'")
	}
	if args.SinkConfigs == nil {
		return nil, errors.New("invalid value for required argument 'SinkConfigs'")
	}
	if args.SinkName == nil {
		return nil, errors.New("invalid value for required argument 'SinkName'")
	}
	if args.TenantName == nil {
		return nil, errors.New("invalid value for required argument 'TenantName'")
	}
	if args.Topic == nil {
		return nil, errors.New("invalid value for required argument 'Topic'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource StreamingSink
	err := ctx.RegisterResource("astra:index/streamingSink:StreamingSink", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStreamingSink gets an existing StreamingSink resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStreamingSink(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StreamingSinkState, opts ...pulumi.ResourceOption) (*StreamingSink, error) {
	var resource StreamingSink
	err := ctx.ReadResource("astra:index/streamingSink:StreamingSink", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering StreamingSink resources.
type streamingSinkState struct {
	// auto ack
	AutoAck *bool `pulumi:"autoAck"`
	// Cloud provider
	CloudProvider *string `pulumi:"cloudProvider"`
	// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
	// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// Pulsar Namespace
	Namespace *string `pulumi:"namespace"`
	// Parallelism for Pulsar sink
	Parallelism *int `pulumi:"parallelism"`
	// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
	ProcessingGuarantees *string `pulumi:"processingGuarantees"`
	// cloud region
	Region *string `pulumi:"region"`
	// Retain ordering.
	RetainOrdering *bool `pulumi:"retainOrdering"`
	// Sink Configs
	SinkConfigs *string `pulumi:"sinkConfigs"`
	// Name of the sink.
	SinkName *string `pulumi:"sinkName"`
	// Streaming tenant name.
	TenantName *string `pulumi:"tenantName"`
	// Streaming tenant topic.
	Topic *string `pulumi:"topic"`
}

type StreamingSinkState struct {
	// auto ack
	AutoAck pulumi.BoolPtrInput
	// Cloud provider
	CloudProvider pulumi.StringPtrInput
	// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
	// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
	DeletionProtection pulumi.BoolPtrInput
	// Pulsar Namespace
	Namespace pulumi.StringPtrInput
	// Parallelism for Pulsar sink
	Parallelism pulumi.IntPtrInput
	// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
	ProcessingGuarantees pulumi.StringPtrInput
	// cloud region
	Region pulumi.StringPtrInput
	// Retain ordering.
	RetainOrdering pulumi.BoolPtrInput
	// Sink Configs
	SinkConfigs pulumi.StringPtrInput
	// Name of the sink.
	SinkName pulumi.StringPtrInput
	// Streaming tenant name.
	TenantName pulumi.StringPtrInput
	// Streaming tenant topic.
	Topic pulumi.StringPtrInput
}

func (StreamingSinkState) ElementType() reflect.Type {
	return reflect.TypeOf((*streamingSinkState)(nil)).Elem()
}

type streamingSinkArgs struct {
	// auto ack
	AutoAck bool `pulumi:"autoAck"`
	// Cloud provider
	CloudProvider string `pulumi:"cloudProvider"`
	// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
	// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// Pulsar Namespace
	Namespace string `pulumi:"namespace"`
	// Parallelism for Pulsar sink
	Parallelism int `pulumi:"parallelism"`
	// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
	ProcessingGuarantees string `pulumi:"processingGuarantees"`
	// cloud region
	Region string `pulumi:"region"`
	// Retain ordering.
	RetainOrdering bool `pulumi:"retainOrdering"`
	// Sink Configs
	SinkConfigs string `pulumi:"sinkConfigs"`
	// Name of the sink.
	SinkName string `pulumi:"sinkName"`
	// Streaming tenant name.
	TenantName string `pulumi:"tenantName"`
	// Streaming tenant topic.
	Topic string `pulumi:"topic"`
}

// The set of arguments for constructing a StreamingSink resource.
type StreamingSinkArgs struct {
	// auto ack
	AutoAck pulumi.BoolInput
	// Cloud provider
	CloudProvider pulumi.StringInput
	// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
	// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
	DeletionProtection pulumi.BoolPtrInput
	// Pulsar Namespace
	Namespace pulumi.StringInput
	// Parallelism for Pulsar sink
	Parallelism pulumi.IntInput
	// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
	ProcessingGuarantees pulumi.StringInput
	// cloud region
	Region pulumi.StringInput
	// Retain ordering.
	RetainOrdering pulumi.BoolInput
	// Sink Configs
	SinkConfigs pulumi.StringInput
	// Name of the sink.
	SinkName pulumi.StringInput
	// Streaming tenant name.
	TenantName pulumi.StringInput
	// Streaming tenant topic.
	Topic pulumi.StringInput
}

func (StreamingSinkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*streamingSinkArgs)(nil)).Elem()
}

type StreamingSinkInput interface {
	pulumi.Input

	ToStreamingSinkOutput() StreamingSinkOutput
	ToStreamingSinkOutputWithContext(ctx context.Context) StreamingSinkOutput
}

func (*StreamingSink) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingSink)(nil)).Elem()
}

func (i *StreamingSink) ToStreamingSinkOutput() StreamingSinkOutput {
	return i.ToStreamingSinkOutputWithContext(context.Background())
}

func (i *StreamingSink) ToStreamingSinkOutputWithContext(ctx context.Context) StreamingSinkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingSinkOutput)
}

// StreamingSinkArrayInput is an input type that accepts StreamingSinkArray and StreamingSinkArrayOutput values.
// You can construct a concrete instance of `StreamingSinkArrayInput` via:
//
//          StreamingSinkArray{ StreamingSinkArgs{...} }
type StreamingSinkArrayInput interface {
	pulumi.Input

	ToStreamingSinkArrayOutput() StreamingSinkArrayOutput
	ToStreamingSinkArrayOutputWithContext(context.Context) StreamingSinkArrayOutput
}

type StreamingSinkArray []StreamingSinkInput

func (StreamingSinkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StreamingSink)(nil)).Elem()
}

func (i StreamingSinkArray) ToStreamingSinkArrayOutput() StreamingSinkArrayOutput {
	return i.ToStreamingSinkArrayOutputWithContext(context.Background())
}

func (i StreamingSinkArray) ToStreamingSinkArrayOutputWithContext(ctx context.Context) StreamingSinkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingSinkArrayOutput)
}

// StreamingSinkMapInput is an input type that accepts StreamingSinkMap and StreamingSinkMapOutput values.
// You can construct a concrete instance of `StreamingSinkMapInput` via:
//
//          StreamingSinkMap{ "key": StreamingSinkArgs{...} }
type StreamingSinkMapInput interface {
	pulumi.Input

	ToStreamingSinkMapOutput() StreamingSinkMapOutput
	ToStreamingSinkMapOutputWithContext(context.Context) StreamingSinkMapOutput
}

type StreamingSinkMap map[string]StreamingSinkInput

func (StreamingSinkMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StreamingSink)(nil)).Elem()
}

func (i StreamingSinkMap) ToStreamingSinkMapOutput() StreamingSinkMapOutput {
	return i.ToStreamingSinkMapOutputWithContext(context.Background())
}

func (i StreamingSinkMap) ToStreamingSinkMapOutputWithContext(ctx context.Context) StreamingSinkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingSinkMapOutput)
}

type StreamingSinkOutput struct{ *pulumi.OutputState }

func (StreamingSinkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingSink)(nil)).Elem()
}

func (o StreamingSinkOutput) ToStreamingSinkOutput() StreamingSinkOutput {
	return o
}

func (o StreamingSinkOutput) ToStreamingSinkOutputWithContext(ctx context.Context) StreamingSinkOutput {
	return o
}

// auto ack
func (o StreamingSinkOutput) AutoAck() pulumi.BoolOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.BoolOutput { return v.AutoAck }).(pulumi.BoolOutput)
}

// Cloud provider
func (o StreamingSinkOutput) CloudProvider() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.CloudProvider }).(pulumi.StringOutput)
}

// Whether or not to allow Terraform to destroy this streaming sink. Unless this field is set to false in Terraform state,
// a `terraform destroy` or `terraform apply` command that deletes the instance will fail. Defaults to `true`.
func (o StreamingSinkOutput) DeletionProtection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.BoolPtrOutput { return v.DeletionProtection }).(pulumi.BoolPtrOutput)
}

// Pulsar Namespace
func (o StreamingSinkOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.Namespace }).(pulumi.StringOutput)
}

// Parallelism for Pulsar sink
func (o StreamingSinkOutput) Parallelism() pulumi.IntOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.IntOutput { return v.Parallelism }).(pulumi.IntOutput)
}

// "ATLEAST*ONCE""ATMOST*ONCE""EFFECTIVELY_ONCE".
func (o StreamingSinkOutput) ProcessingGuarantees() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.ProcessingGuarantees }).(pulumi.StringOutput)
}

// cloud region
func (o StreamingSinkOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Retain ordering.
func (o StreamingSinkOutput) RetainOrdering() pulumi.BoolOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.BoolOutput { return v.RetainOrdering }).(pulumi.BoolOutput)
}

// Sink Configs
func (o StreamingSinkOutput) SinkConfigs() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.SinkConfigs }).(pulumi.StringOutput)
}

// Name of the sink.
func (o StreamingSinkOutput) SinkName() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.SinkName }).(pulumi.StringOutput)
}

// Streaming tenant name.
func (o StreamingSinkOutput) TenantName() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.TenantName }).(pulumi.StringOutput)
}

// Streaming tenant topic.
func (o StreamingSinkOutput) Topic() pulumi.StringOutput {
	return o.ApplyT(func(v *StreamingSink) pulumi.StringOutput { return v.Topic }).(pulumi.StringOutput)
}

type StreamingSinkArrayOutput struct{ *pulumi.OutputState }

func (StreamingSinkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StreamingSink)(nil)).Elem()
}

func (o StreamingSinkArrayOutput) ToStreamingSinkArrayOutput() StreamingSinkArrayOutput {
	return o
}

func (o StreamingSinkArrayOutput) ToStreamingSinkArrayOutputWithContext(ctx context.Context) StreamingSinkArrayOutput {
	return o
}

func (o StreamingSinkArrayOutput) Index(i pulumi.IntInput) StreamingSinkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *StreamingSink {
		return vs[0].([]*StreamingSink)[vs[1].(int)]
	}).(StreamingSinkOutput)
}

type StreamingSinkMapOutput struct{ *pulumi.OutputState }

func (StreamingSinkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StreamingSink)(nil)).Elem()
}

func (o StreamingSinkMapOutput) ToStreamingSinkMapOutput() StreamingSinkMapOutput {
	return o
}

func (o StreamingSinkMapOutput) ToStreamingSinkMapOutputWithContext(ctx context.Context) StreamingSinkMapOutput {
	return o
}

func (o StreamingSinkMapOutput) MapIndex(k pulumi.StringInput) StreamingSinkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *StreamingSink {
		return vs[0].(map[string]*StreamingSink)[vs[1].(string)]
	}).(StreamingSinkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StreamingSinkInput)(nil)).Elem(), &StreamingSink{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamingSinkArrayInput)(nil)).Elem(), StreamingSinkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamingSinkMapInput)(nil)).Elem(), StreamingSinkMap{})
	pulumi.RegisterOutputType(StreamingSinkOutput{})
	pulumi.RegisterOutputType(StreamingSinkArrayOutput{})
	pulumi.RegisterOutputType(StreamingSinkMapOutput{})
}
